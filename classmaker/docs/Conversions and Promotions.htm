<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0075)http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html -->
<HTML><HEAD><TITLE>Conversions and Promotions</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<META content=exclude name=collection>
<META content="MSHTML 6.00.2900.6082" name=GENERATOR></HEAD>
<BODY text=#000000 vLink=#000077 aLink=#ff0000 link=#0000ff bgColor=#eeeeff>
<TABLE width="100%" border=0>
  <TBODY>
  <TR>
    <TD><A 
      href="http://java.sun.com/docs/books/jls/second_edition/html/jTOC.doc.html">Contents</A> 
      | <A 
      href="http://java.sun.com/docs/books/jls/second_edition/html/typesValues.doc.html">Prev</A> 
      | <A 
      href="http://java.sun.com/docs/books/jls/second_edition/html/names.doc.html">Next</A> 
      | <A 
      href="http://java.sun.com/docs/books/jls/second_edition/html/jIX.fm.html">Index</A></TD>
    <TD align=right><I>Java Language Specification</I><BR><FONT size=-1>Second 
      Edition</FONT></TD></TR></TBODY></TABLE>
<HR>
<BR><A name=44342></A>
<P><STRONG>CHAPTER 5 </STRONG></P><A name=27529></A>
<H1>Conversions and Promotions</H1>
<HR>

<P><A name=25009></A>Every expression written in the Java programming language 
has a type that can be deduced from the structure of the expression and the 
types of the literals, variables, and methods mentioned in the expression. It is 
possible, however, to write an expression in a context where the type of the 
expression is not appropriate. In some cases, this leads to an error at compile 
time; for example, if the expression in an <CODE>if</CODE> statement <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/statements.doc.html#5991">(§14.9)</A> 
has any type other than <CODE>boolean</CODE>, a compile-time error occurs. In 
other cases, the context may be able to accept a type that is related to the 
type of the expression; as a convenience, rather than requiring the programmer 
to indicate a type conversion explicitly, the language performs an implicit 
<EM>conversion</EM> from the type of the expression to a type acceptable for its 
surrounding context.
<P><A name=189998></A>A specific conversion from type <I>S</I> to type <I>T</I> 
allows an expression of type <I>S</I> to be treated at compile time as if it had 
type <I>T</I> instead. In some cases this will require a corresponding action at 
run time to check the validity of the conversion or to translate the run-time 
value of the expression into a form appropriate for the new type <I>T</I>. For 
example:
<P>
<UL><A name=190003></A>
  <LI>A conversion from type <CODE>Object</CODE> to type <CODE>Thread</CODE> 
  requires a run-time check to make sure that the run-time value is actually an 
  instance of class <CODE>Thread</CODE> or one of its subclasses; if it is not, 
  an exception is thrown. <A name=25042></A>
  <LI>A conversion from type <CODE>Thread</CODE> to type <CODE>Object</CODE> 
  requires no run-time action; <CODE>Thread</CODE> is a subclass of 
  <CODE>Object</CODE>, so any reference produced by an expression of type 
  <CODE>Thread</CODE> is a valid reference value of type <CODE>Object</CODE>. <A 
  name=25043></A>
  <LI>A conversion from type <CODE>int</CODE> to type <CODE>long</CODE> requires 
  run-time sign-extension of a 32-bit integer value to the 64-bit 
  <CODE>long</CODE> representation. No information is lost. <A 
  name=185533></A></LI></UL>A conversion from type <CODE>double</CODE> to type 
<CODE>long</CODE> requires a nontrivial translation from a 64-bit floating-point 
value to the 64-bit integer representation. Depending on the actual run-time 
value, information may be lost. 
<P>In every conversion context, only certain specific conversions are permitted. 
For convenience of description, the specific conversions that are possible in 
the Java programming language are grouped into several broad categories: <A 
name=25070></A>
<UL>
  <LI>Identity conversions <A name=25071></A>
  <LI>Widening primitive conversions <A name=25072></A>
  <LI>Narrowing primitive conversions <A name=25073></A>
  <LI>Widening reference conversions <A name=184139></A>
  <LI>Narrowing reference conversions <A name=184140></A>
  <LI>String conversions <A name=184148></A>
  <LI>Value set conversions </LI></UL><A name=185434></A>There are five 
<EM>conversion contexts</EM> in which conversion of expressions may occur. Each 
context allows conversions in some of the categories named above but not others. 
The term "conversion" is also used to describe the process of choosing a 
specific conversion for such a context. For example, we say that an expression 
that is an actual argument in a method invocation is subject to "method 
invocation conversion," meaning that a specific conversion will be implicitly 
chosen for that expression according to the rules for the method invocation 
argument context.
<P><A name=185543></A>One conversion context is the operand of a numeric 
operator such as <CODE>+</CODE> or <CODE>*</CODE>. The conversion process for 
such operands is called <EM>numeric promotion</EM>. Promotion is special in 
that, in the case of binary operators, the conversion chosen for one operand may 
depend in part on the type of the other operand expression. <A 
name=189322></A>This chapter first describes the seven categories of conversions 
<A 
href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#189955">(§5.1)</A>, 
including the special conversions to <CODE>String</CODE> allowed for the string 
concatenation operator <CODE>+</CODE>. Then the five conversion contexts are 
described: 
<UL><A name=25117></A>
  <LI>Assignment conversion (<A 
  href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#184206">§5.2</A>, 
  <A 
  href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#5281">§15.26</A>) 
  converts the type of an expression to the type of a specified variable. The 
  conversions permitted for assignment are limited in such a way that assignment 
  conversion never causes an exception. <A name=52883></A>
  <LI>Method invocation conversion (<A 
  href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#12687">§5.3</A>, 
  <A 
  href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#41147">§15.9</A>, 
  <A 
  href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#20448">§15.12</A>) 
  is applied to each argument in a method or constructor invocation and, except 
  in one case, performs the same conversions that assignment conversion does. 
  Method invocation conversion never causes an exception. <A name=25151></A>
  <LI>Casting conversion <A 
  href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#20232">(§5.5)</A> 
  converts the type of an expression to a type explicitly specified by a cast 
  operator <A 
  href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#238146">(§15.16)</A>. 
  It is more inclusive than assignment or method invocation conversion, allowing 
  any specific conversion other than a string conversion, but certain casts to a 
  reference type may cause an exception at run time. <A name=25179></A>
  <LI>String conversion (<A 
  href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#186035">§5.4</A>, 
  <A 
  href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#39990">§15.18.1</A>) 
  allows any type to be converted to type <CODE>String</CODE>. <A 
name=52885></A>
  <LI>Numeric promotion <A 
  href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#26917">(§5.6)</A> 
  brings the operands of a numeric operator to a common type so that an 
  operation can be performed. </LI></UL><A name=185443></A>Here are some examples 
of the various contexts for conversion: 
<UL></UL>
<BLOCKQUOTE><PRE>class Test {			

	public static void main(String[] args) {

		// Casting conversion <A href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#186035">(§5.4)</A> of a float literal to
		// type int. Without the cast operator, this would
		// be a compile-time error, because this is a
		// narrowing conversion <A href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#25363">(§5.1.3)</A>:
		int i = (int)12.5f;

		// String conversion <A href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#186035">(§5.4)</A> of i's int value:
		System.out.println("(int)12.5f==" + i);

		// Assignment conversion <A href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#184206">(§5.2)</A> of i's value to type
		// float. This is a widening conversion <A href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#25214">(§5.1.2)</A>:
		float f = i;

		// String conversion of f's float value:
		System.out.println("after float widening: " + f);

		// Numeric promotion <A href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#26917">(§5.6)</A> of i's value to type
		// float. This is a binary numeric promotion.
		// After promotion, the operation is float*float:
		System.out.print(f);
		f = f * i;

		// Two string conversions of i and f:
		System.out.println("*" + i + "==" + f);

		// Method invocation conversion <A href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#12687">(§5.3)</A> of f's value
		// to type double, needed because the method Math.sin
		// accepts only a double argument:
		double d = Math.sin(f);

		// Two string conversions of f and d:
		System.out.println("Math.sin(" + f + ")==" + d);
	}
}
</PRE></BLOCKQUOTE><A name=26253></A>which produces the output:
<P>
<BLOCKQUOTE><PRE>(int)12.5f==12
after float widening: 12.0
12.0*12==144.0
Math.sin(144.0)==-0.49102159389846934
</PRE></BLOCKQUOTE><A name=189955></A>
<H2>5.1 Kinds of Conversion</H2><A name=25201></A>Specific type conversions in 
the Java programming language are divided into seven categories.
<P><A name=25209></A>
<H3>5.1.1 Identity Conversions</H3><A name=185447></A>A conversion from a type 
to that same type is permitted for any type. 
<P><A name=185451></A>This may seem trivial, but it has two practical 
consequences. First, it is always permitted for an expression to have the 
desired type to begin with, thus allowing the simply stated rule that every 
expression is subject to conversion, if only a trivial identity conversion. 
Second, it implies that it is permitted for a program to include redundant cast 
operators for the sake of clarity. <A name=185553></A>
<P>The only permitted conversion that involves the type <CODE>boolean</CODE> is 
the identity conversion from <CODE>boolean</CODE> to <CODE>boolean</CODE>. <A 
name=25214></A>
<H3>5.1.2 Widening Primitive Conversion</H3><A name=25224></A>The following 19 
specific conversions on primitive types are called the <EM>widening primitive 
conversions</EM>:
<P>
<UL><A name=25225></A>
  <LI><CODE>byte</CODE> to <CODE>short</CODE>, <CODE>int</CODE>, 
  <CODE>long</CODE>, <CODE>float</CODE>, or <CODE>double</CODE> <A 
  name=25226></A>
  <LI><CODE>short</CODE> to <CODE>int</CODE>, <CODE>long</CODE>, 
  <CODE>float</CODE>, or <CODE>double</CODE> <A name=25227></A>
  <LI><CODE>char</CODE> to <CODE>int</CODE>, <CODE>long</CODE>, 
  <CODE>float</CODE>, or <CODE>double</CODE> <A name=25228></A>
  <LI><CODE>int</CODE> to <CODE>long</CODE>, <CODE>float</CODE>, or 
  <CODE>double</CODE> <A name=25229></A>
  <LI><CODE>long</CODE> to <CODE>float</CODE> or <CODE>double</CODE> <A 
  name=25230></A>
  <LI><CODE>float</CODE> to <CODE>double</CODE> </LI></UL><A 
name=25231></A>Widening primitive conversions do not lose information about the 
overall magnitude of a numeric value. Indeed, conversions widening from an 
integral type to another integral type and from <CODE>float</CODE> to 
<CODE>double</CODE> do not lose any information at all; the numeric value is 
preserved exactly. Conversions widening from <CODE>float</CODE> to 
<CODE>double</CODE> in <CODE>strictfp</CODE> expressions also preserve the 
numeric value exactly; however, such conversions that are not 
<CODE>strictfp</CODE> may lose information about the overall magnitude of the 
converted value.
<P><A name=185724></A>Conversion of an <CODE>int</CODE> or a <CODE>long</CODE> 
value to <CODE>float</CODE>, or of a <CODE>long</CODE> value to 
<CODE>double</CODE>, may result in <EM>loss of precision</EM>-that is, the 
result may lose some of the least significant bits of the value. In this case, 
the resulting floating-point value will be a correctly rounded version of the 
integer value, using IEEE 754 round-to-nearest mode <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/typesValues.doc.html#9249">(§4.2.4)</A>.
<P><A name=25237></A>A widening conversion of a signed integer value to an 
integral type <I>T</I> simply sign-extends the two's-complement representation 
of the integer value to fill the wider format. A widening conversion of a 
character to an integral type <I>T</I> zero-extends the representation of the 
character value to fill the wider format.
<P><A name=185453></A>Despite the fact that loss of precision may occur, 
widening conversions among primitive types never result in a run-time exception 
<A 
href="http://java.sun.com/docs/books/jls/second_edition/html/exceptions.doc.html#44043">(§11)</A>.
<P><A name=25242></A>Here is an example of a widening conversion that loses 
precision: 
<BLOCKQUOTE><PRE>class Test {
	public static void main(String[] args) {
		int big = 1234567890;
		float approx = big;
		System.out.println(big - (int)approx);
	}
}
</PRE></BLOCKQUOTE><A name=25250></A>which prints:
<P>
<BLOCKQUOTE><PRE>-46
</PRE></BLOCKQUOTE><A name=185558></A>thus indicating that information was lost 
during the conversion from type <CODE>int</CODE> to type <CODE>float</CODE> 
because values of type <CODE>float</CODE> are not precise to nine significant 
digits.
<P><A name=25363></A>
<H3>5.1.3 Narrowing Primitive Conversions</H3><A name=185663></A>The following 
23 specific conversions on primitive types are called the <EM>narrowing</EM> 
<EM>primitive conversions</EM>:
<P>
<UL><A name=25257></A>
  <LI><CODE>byte</CODE> to <CODE>char</CODE> <A name=25258></A>
  <LI><CODE>short</CODE> to <CODE>byte</CODE> or <CODE>char</CODE> <A 
  name=25259></A>
  <LI><CODE>char</CODE> to <CODE>byte</CODE> or <CODE>short</CODE> <A 
  name=25260></A>
  <LI><CODE>int</CODE> to <CODE>byte</CODE>, <CODE>short</CODE>, or 
  <CODE>char</CODE> <A name=25261></A>
  <LI><CODE>long</CODE> to <CODE>byte</CODE>, <CODE>short</CODE>, 
  <CODE>char</CODE>, or <CODE>int</CODE> <A name=25262></A>
  <LI><CODE>float</CODE> to <CODE>byte</CODE>, <CODE>short</CODE>, 
  <CODE>char</CODE>, <CODE>int</CODE>, or <CODE>long</CODE> <A name=25263></A>
  <LI><CODE>double</CODE> to <CODE>byte</CODE>, <CODE>short</CODE>, 
  <CODE>char</CODE>, <CODE>int</CODE>, <CODE>long</CODE>, or <CODE>float</CODE> 
  </LI></UL><A name=25264></A>Narrowing conversions may lose information about the 
overall magnitude of a numeric value and may also lose precision.
<P><A name=25265></A>A narrowing conversion of a signed integer to an integral 
type <I>T</I> simply discards all but the <EM>n </EM>lowest order bits, where 
<EM>n </EM>is the number of bits used to represent type <I>T</I>. In addition to 
a possible loss of information about the magnitude of the numeric value, this 
may cause the sign of the resulting value to differ from the sign of the input 
value.
<P><A name=25266></A>A narrowing conversion of a character to an integral type 
<I>T</I> likewise simply discards all but the <EM>n </EM>lowest order bits, 
where <EM>n </EM>is the number of bits used to represent type <I>T</I>. In 
addition to a possible loss of information about the magnitude of the numeric 
value, this may cause the resulting value to be a negative number, even though 
characters represent 16-bit unsigned integer values.
<P><A name=25267></A>A narrowing conversion of a floating-point number to an 
integral type <I>T</I> takes two steps:
<P>
<OL><A name=25268></A>
  <LI>In the first step, the floating-point number is converted either to a 
  <CODE>long</CODE>, if <I>T</I> is <CODE>long</CODE>, or to an 
  <CODE>int</CODE>, if <I>T</I> is <CODE>byte</CODE>, <CODE>short</CODE>, 
  <CODE>char</CODE>, or <CODE>int</CODE>, as follows: 
  <UL><A name=25272></A>
    <LI>If the floating-point number is NaN <A 
    href="http://java.sun.com/docs/books/jls/second_edition/html/typesValues.doc.html#9208">(§4.2.3)</A>, 
    the result of the first step of the conversion is an <CODE>int</CODE> or 
    <CODE>long</CODE> <CODE>0</CODE>. <A name=174285></A>
    <LI>Otherwise, if the floating-point number is not an infinity, the 
    floating-point value is rounded to an integer value <I>V</I>, rounding 
    toward zero using IEEE 754 round-toward-zero mode <A 
    href="http://java.sun.com/docs/books/jls/second_edition/html/typesValues.doc.html#9208">(§4.2.3)</A>. 
    Then there are two cases: 
    <UL><A name=25277></A>
      <LI>If <I>T</I> is <CODE>long</CODE>, and this integer value can be 
      represented as a <CODE>long</CODE>, then the result of the first step is 
      the <CODE>long</CODE> value <I>V</I>. <A name=25278></A>
      <LI>Otherwise, if this integer value can be represented as an 
      <CODE>int</CODE>, then the result of the first step is the 
      <CODE>int</CODE> value <I>V</I>. </LI></UL><A name=25279></A>
    <LI>Otherwise, one of the following two cases must be true: 
    <UL><A name=25280></A>
      <LI>The value must be too small (a negative value of large magnitude or 
      negative infinity), and the result of the first step is the smallest 
      representable value of type <CODE>int</CODE> or <CODE>long</CODE>. <A 
      name=25281></A>
      <LI>The value must be too large (a positive value of large magnitude or 
      positive infinity), and the result of the first step is the largest 
      representable value of type <CODE>int</CODE> or <CODE>long</CODE>. 
    </LI></UL></LI></UL><A name=25282></A>
  <LI>In the second step: 
  <UL><A name=25283></A>
    <LI>If <I>T</I> is <CODE>int</CODE> or <CODE>long</CODE>, the result of the 
    conversion is the result of the first step. <A name=25284></A>
    <LI>If <I>T</I> is <CODE>byte</CODE>, <CODE>char</CODE>, or 
    <CODE>short</CODE>, the result of the conversion is the result of a 
    narrowing conversion to type <I>T</I> <A 
    href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#25363">(§5.1.3)</A> 
    of the result of the first step. </LI></UL></LI></OL><A name=176319></A>The 
example:
<P>
<BLOCKQUOTE><PRE>class Test {
	public static void main(String[] args) {
		float fmin = Float.NEGATIVE_INFINITY;
		float fmax = Float.POSITIVE_INFINITY;
		System.out.println("long: " + (long)fmin +
						".." + (long)fmax);
		System.out.println("int: " + (int)fmin +
						".." + (int)fmax);
		System.out.println("short: " + (short)fmin +
						".." + (short)fmax);
		System.out.println("char: " + (int)(char)fmin +
						".." + (int)(char)fmax);
		System.out.println("byte: " + (byte)fmin +
						".." + (byte)fmax);
	}
}
</PRE></BLOCKQUOTE><A name=25305></A>produces the output:
<P>
<BLOCKQUOTE><PRE>long: -9223372036854775808..9223372036854775807
int: -2147483648..2147483647
short: 0..-1
char: 0..65535
byte: 0..-1
<A name=25311></A>
</PRE></BLOCKQUOTE>The results for <CODE>char</CODE>, <CODE>int</CODE>, and 
<CODE>long</CODE> are unsurprising, producing the minimum and maximum 
representable values of the type. <A name=185563></A>
<P>The results for <CODE>byte</CODE> and <CODE>short</CODE> lose information 
about the sign and magnitude of the numeric values and also lose precision. The 
results can be understood by examining the low order bits of the minimum and 
maximum <CODE>int.</CODE> The minimum <CODE>int</CODE> is, in hexadecimal, 
<CODE>0x80000000</CODE>, and the maximum <CODE>int</CODE> is 
<CODE>0x7fffffff</CODE>. This explains the <CODE>short</CODE> results, which are 
the low 16 bits of these values, namely, <CODE>0x0000</CODE> and 
<CODE>0xffff</CODE>; it explains the <CODE>char</CODE> results, which also are 
the low 16 bits of these values, namely, <CODE>'\u0000'</CODE> and 
<CODE>'\uffff'</CODE>; and it explains the <CODE>byte</CODE> results, which are 
the low 8 bits of these values, namely, <CODE>0x00</CODE> and <CODE>0xff</CODE>. 
<PRE></PRE>
<BLOCKQUOTE></BLOCKQUOTE><A name=185465></A>Despite the fact that overflow, 
underflow, or other loss of information may occur, narrowing conversions among 
primitive types never result in a run-time exception <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/exceptions.doc.html#44043">(§11)</A>.
<P><A name=189966></A>Here is a small test program that demonstrates a number of 
narrowing conversions that lose information:
<P>
<BLOCKQUOTE><PRE>class Test {
	public static void main(String[] args) {

		// A narrowing of int to short loses high bits:
		System.out.println("(short)0x12345678==0x" +
					Integer.toHexString((short)0x12345678));

		// A int value not fitting in byte changes sign and magnitude:
		System.out.println("(byte)255==" + (byte)255);

		// A float value too big to fit gives largest int value:
		System.out.println("(int)1e20f==" + (int)1e20f);

		// A NaN converted to int yields zero:
		System.out.println("(int)NaN==" + (int)Float.NaN);
		
		// A double value too large for float yields infinity:
		System.out.println("(float)-1e100==" + (float)-1e100);

		// A double value too small for float underflows to zero:
		System.out.println("(float)1e-50==" + (float)1e-50);
	}
}
</PRE></BLOCKQUOTE><A name=25347></A>This test program produces the following 
output:
<P>
<BLOCKQUOTE><PRE>(short)0x12345678==0x5678
(byte)255==-1
(int)1e20f==2147483647
(int)NaN==0
(float)-1e100==-Infinity
(float)1e-50==0.0
</PRE></BLOCKQUOTE><A name=25215></A>
<H3>5.1.4 Widening Reference Conversions</H3><A name=25460></A>The following 
conversions are called the <EM>widening reference conversions</EM>:
<P>
<UL><A name=25482></A>
  <LI>From any class type <I>S</I> to any class type <I>T</I>, provided that 
  <I>S</I> is a subclass of <I>T</I>. (An important special case is that there 
  is a widening conversion to the class type <CODE>Object</CODE> from any other 
  class type.) <A name=25484></A>
  <LI>From any class type <I>S</I> to any interface type <I>K</I>, provided that 
  <I>S</I> implements <I>K</I>. <A name=25483></A>
  <LI>From the null type to any class type, interface type, or array type. <A 
  name=25502></A>
  <LI>From any interface type <I>J</I> to any interface type <I>K</I>, provided 
  that <I>J</I> is a subinterface of <I>K</I>. <A name=25500></A>
  <LI>From any interface type to type <CODE>Object</CODE>. <A name=174846></A>
  <LI>From any array type to type <CODE>Object</CODE>. <A name=174848></A>
  <LI>From any array type to type <CODE>Cloneable</CODE>. <A name=184037></A>
  <LI>From any array type to type <CODE>java.io.Serializable</CODE> <A 
  name=25525></A>
  <LI>From any array type <I>SC</I><CODE>[]</CODE> to any array type 
  <I>TC</I><CODE>[]</CODE>, provided that <I>SC</I> and <I>TC</I> are reference 
  types and there is a widening conversion from <I>SC</I> to <I>TC</I>. 
</LI></UL><A name=25616></A>Such conversions never require a special action at 
run time and therefore never throw an exception at run time. They consist simply 
in regarding a reference as having some other type in a manner that can be 
proved correct at compile time.
<P><A name=25457></A>See <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/classes.doc.html#3857">§8</A> 
for the detailed specifications for classes, <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/interfaces.doc.html#238678">§9</A> 
for interfaces, and <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/arrays.doc.html#27803">§10</A> 
for arrays.
<P><A name=25379></A>
<H3>5.1.5 Narrowing Reference Conversions</H3><A name=175454></A>The following 
conversions are called the <EM>narrowing reference conversions</EM>:
<P>
<UL><A name=175455></A>
  <LI>From any class type <I>S</I> to any class type <I>T</I>, provided that 
  <I>S</I> is a superclass of <I>T</I>. (An important special case is that there 
  is a narrowing conversion from the class type <CODE>Object</CODE> to any other 
  class type.) <A name=25705></A>
  <LI>From any class type <I>S</I> to any interface type <I>K</I>, provided that 
  <I>S</I> is not final and does not implement <I>K.</I> (An important special 
  case is that there is a narrowing conversion from the class type 
  <CODE>Object</CODE> to any interface type.) <A name=25766></A>
  <LI>From type <CODE>Object</CODE> to any array type. <A name=175692></A>
  <LI>From type <CODE>Object</CODE> to any interface type. <A name=25783></A>
  <LI>From any interface type <I>J</I> to any class type <I>T</I> that is not 
  <CODE>final</CODE>. <A name=25787></A>
  <LI>From any interface type <I>J</I> to any class type <I>T</I> that is 
  <CODE>final</CODE>, provided that <I>T</I> implements <I>J</I>. <A 
  name=25774></A>
  <LI>From any interface type <I>J</I> to any interface type <I>K</I>, provided 
  that <I>J</I> is not a subinterface of <I>K</I> and there is no method name 
  <I>m</I> such that <I>J</I> and <I>K</I> both contain a method named <I>m</I> 
  with the same signature but different return types. <A name=25710></A>
  <LI>From any array type <I>SC</I><CODE>[]</CODE> to any array type 
  <I>TC</I><CODE>[]</CODE>, provided that <I>SC</I> and <I>TC</I> are reference 
  types and there is a narrowing conversion from <I>SC</I> to <I>TC</I>. 
</LI></UL><A name=176885></A>Such conversions require a test at run time to find 
out whether the actual reference value is a legitimate value of the new type. If 
not, then a <CODE>ClassCastException</CODE> is thrown.
<P><A name=176886></A>
<H3>5.1.6 String Conversions</H3><A name=175033></A>There is a string conversion 
to type <CODE>String</CODE> from every other type, including the null type.
<P><A name=175034></A>
<H3>5.1.7 Forbidden Conversions</H3>
<UL><A name=175035></A>
  <LI>There is no permitted conversion from any reference type to any primitive 
  type. <A name=25844></A>
  <LI>Except for the string conversions, there is no permitted conversion from 
  any primitive type to any reference type. <A name=25860></A>
  <LI>There is no permitted conversion from the null type to any primitive type. 
  <A name=25835></A>
  <LI>There is no permitted conversion to the null type other than the identity 
  conversion. <A name=25993></A>
  <LI>There is no permitted conversion to the type <CODE>boolean</CODE> other 
  than the identity conversion. <A name=25997></A>
  <LI>There is no permitted conversion from the type <CODE>boolean</CODE> other 
  than the identity conversion and string conversion. <A name=25357></A>
  <LI>There is no permitted conversion other than string conversion from class 
  type <I>S</I> to a different class type <I>T</I> if <I>S</I> is not a subclass 
  of <I>T</I> and <I>T</I> is not a subclass of <I>S</I>. <A name=25885></A>
  <LI>There is no permitted conversion from class type <I>S</I> to interface 
  type <I>K</I> if <I>S</I> is <CODE>final</CODE> and does not implement 
  <I>K</I>. <A name=25899></A>
  <LI>There is no permitted conversion from class type <I>S</I> to any array 
  type if <I>S</I> is not <CODE>Object</CODE>. <A name=25902></A>
  <LI>There is no permitted conversion other than string conversion from 
  interface type <I>J</I> to class type <I>T</I> if <I>T</I> is 
  <CODE>final</CODE> and does not implement <I>J</I>. <A name=25924></A>
  <LI>There is no permitted conversion from interface type <I>J</I> to interface 
  type <I>K</I> if <I>J</I> and <I>K</I> contain methods with the same signature 
  but different return types. <A name=25954></A>
  <LI>There is no permitted conversion from any array type to any class type 
  other than <CODE>Object</CODE> or <CODE>String</CODE>. <A name=25958></A>
  <LI>There is no permitted conversion from any array type to any interface 
  type, except to the interface types <CODE>java.io.Serializable</CODE> and 
  <CODE>Cloneable</CODE>, which are implemented by all arrays. <A 
  name=184224></A>
  <LI>There is no permitted conversion from array type <I>SC</I><CODE>[]</CODE> 
  to array type <I>TC</I><CODE>[]</CODE> if there is no permitted conversion 
  other than a string conversion from <I>SC</I> to <I>TC.</I> </LI></UL><A 
name=184225></A>
<H3>5.1.8 Value Set Conversion</H3><A name=184226></A><EM>Value set 
conversion</EM> is the process of mapping a floating-point value from one value 
set to another without changing its type.
<P><A name=184212></A>Within an expression that is not FP-strict <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#249198">(§15.4)</A>, 
value set conversion provides choices to an implementation of the Java 
programming language:
<P>
<UL><A name=184213></A>
  <LI>If the value is an element of the float-extended-exponent value set, then 
  the implementation may, at its option, map the value to the nearest element of 
  the float value set. This conversion may result in overflow (in which case the 
  value is replaced by an infinity of the same sign) or underflow (in which case 
  the value may lose precision because it is replaced by a denormalized number 
  or zero of the same sign). <A name=184214></A>
  <LI>If the value is an element of the double-extended-exponent value set, then 
  the implementation may, at its option, map the value to the nearest element of 
  the double value set. This conversion may result in overflow (in which case 
  the value is replaced by an infinity of the same sign) or underflow (in which 
  case the value may lose precision because it is replaced by a denormalized 
  number or zero of the same sign). </LI></UL><A name=184215></A>Within an 
FP-strict expression <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#249198">(§15.4)</A>, 
value set conversion does not provide any choices; every implementation must 
behave in the same way:
<P>
<UL><A name=184216></A>
  <LI>If the value is of type <CODE>float</CODE> and is not an element of the 
  float value set, then the implementation must map the value to the nearest 
  element of the float value set. This conversion may result in overflow or 
  underflow. <A name=184217></A>
  <LI>If the value is of type <CODE>double</CODE> and is not an element of the 
  double value set, then the implementation must map the value to the nearest 
  element of the double value set. This conversion may result in overflow or 
  underflow. </LI></UL><A name=184218></A>Within an FP-strict expression, mapping 
values from the float-extended-exponent value set or double-extended-exponent 
value set is necessary only when a method is invoked whose declaration is not 
FP-strict and the implementation has chosen to represent the result of the 
method invocation as an element of an extended-exponent value set.
<P><A name=184219></A>Whether in FP-strict code or code that is not FP-strict, 
value set conversion always leaves unchanged any value whose type is neither 
<CODE>float</CODE> nor <CODE>double</CODE>.
<P><A name=184206></A>
<H2>5.2 Assignment Conversion</H2><A name=170769></A><EM>Assignment 
conversion</EM> occurs when the value of an expression is assigned <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#5281">(§15.26)</A> 
to a variable: the type of the expression must be converted to the type of the 
variable. Assignment contexts allow the use of an identity conversion <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#25209">(§5.1.1)</A>, 
a widening primitive conversion <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#25214">(§5.1.2)</A>, 
or a widening reference conversion <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#25215">(§5.1.4)</A>. 
In addition, a narrowing primitive conversion may be used if all of the 
following conditions are satisfied:
<P>
<UL><A name=26335></A>
  <LI>The expression is a constant expression of type <CODE>byte</CODE>, 
  <CODE>short</CODE>, <CODE>char</CODE> or <CODE>int</CODE>. <A name=26336></A>
  <LI>The type of the variable is <CODE>byte</CODE>, <CODE>short</CODE>, or 
  <CODE>char</CODE>. <A name=26337></A>
  <LI>The value of the expression (which is known at compile time, because it is 
  a constant expression) is representable in the type of the variable. 
</LI></UL><A name=26341></A>If the type of the expression cannot be converted to 
the type of the variable by a conversion permitted in an assignment context, 
then a compile-time error occurs.
<P><A name=184230></A>If the type of the variable is <CODE>float</CODE> or 
<CODE>double</CODE>, then value set conversion is applied after the type 
conversion:
<P>
<UL><A name=184231></A>
  <LI>If the value is of type <CODE>float</CODE> and is an element of the 
  float-extended-exponent value set, then the implementation must map the value 
  to the nearest element of the float value set. This conversion may result in 
  overflow or underflow. <A name=184232></A>
  <LI>If the value is of type <CODE>double</CODE> and is an element of the 
  double-extended-exponent value set, then the implementation must map the value 
  to the nearest element of the double value set. This conversion may result in 
  overflow or underflow. </LI></UL><A name=22422></A>If the type of an expression 
can be converted to the type of a variable by assignment conversion, we say the 
expression (or its value) is <EM>assignable to</EM> the variable or, 
equivalently, that the type of the expression is <EM>assignment compatible 
with</EM> the type of the variable.
<P><A name=185470></A>An assignment conversion never causes an exception. (Note, 
however, that an assignment may result in an exception in a special case 
involving array elements -see <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/arrays.doc.html#11430">§10.10</A> 
and <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#5295">§15.26.1</A>.)
<P><A name=28552></A>The compile-time narrowing of constants means that code 
such as: 
<BLOCKQUOTE><PRE>byte theAnswer = 42;
</PRE></BLOCKQUOTE><A name=170786></A>is allowed. Without the narrowing, the 
fact that the integer literal <CODE>42</CODE> has type <CODE>int</CODE> would 
mean that a cast to <CODE>byte</CODE> would be required:
<P>
<BLOCKQUOTE><PRE>byte theAnswer = (byte)42;		// cast is permitted but not required
</PRE></BLOCKQUOTE><A name=185475></A>A value of primitive type must not be 
assigned to a variable of reference type; an attempt to do so will result in a 
compile-time error. A value of type <CODE>boolean</CODE> can be assigned only to 
a variable of type <CODE>boolean</CODE>.
<P><A name=187261></A>The following test program contains examples of assignment 
conversion of primitive values: 
<BLOCKQUOTE><PRE>class Test {
	public static void main(String[] args) {
		short s = 12;			// narrow 12 to short
		float f = s;			// widen short to float
		System.out.println("f=" + f);

		char c = '\u0123';
		long l = c;			// widen char to long
		System.out.println("l=0x" + Long.toString(l,16));

		f = 1.23f;
		double d = f;			// widen float to double
		System.out.println("d=" + d);
	}
}
</PRE></BLOCKQUOTE><A name=13013></A>It produces the following output:
<P>
<BLOCKQUOTE><PRE>f=12.0	
l=0x123
d=1.2300000190734863
</PRE></BLOCKQUOTE><A name=13041></A>The following test, however, produces 
compile-time errors:
<P>
<BLOCKQUOTE><PRE>class Test {
	public static void main(String[] args) {
		short s = 123;
		char c = s;			// error: would require cast
		s = c;				// error: would require cast
	}
}
</PRE></BLOCKQUOTE><A name=189974></A>because not all <CODE>short</CODE> values 
are <CODE>char</CODE> values, and neither are all <CODE>char</CODE> values 
<CODE>short</CODE> values.
<P><A name=185480></A>A value of the null type (the null reference is the only 
such value) may be assigned to any reference type, resulting in a null reference 
of that type.
<P><A name=26417></A>Here is a sample program illustrating assignments of 
references: 
<BLOCKQUOTE><PRE>public class Point { int x, y; }
public class Point3D extends Point { int z; }
public interface Colorable {
	void setColor(int color);
}
public class ColoredPoint extends Point implements Colorable 
{
	int color;
	public void setColor(int color) { this.color = color; }
}
class Test {
	public static void main(String[] args) {
		// Assignments to variables of class type:
		Point p = new Point();
		p = new Point3D();		// ok: because Point3D is a
						// subclass of Point

		Point3D p3d = p;		// error: will require a cast because a 
						// Point might not be a Point3D
						// (even though it is, dynamically,
						// in this example.)

		// Assignments to variables of type Object:
		Object o = p;			// ok: any object to Object
		int[] a = new int[3];
		Object o2 = a;			// ok: an array to Object

		// Assignments to variables of interface type:
		ColoredPoint cp = new ColoredPoint();
		Colorable c = cp;		// ok: ColoredPoint implements
						// Colorable

		// Assignments to variables of array type:
		byte[] b = new byte[4];
		a = b;				// error: these are not arrays
						// of the same primitive type
		Point3D[] p3da = new Point3D[3];
		Point[] pa = p3da;		// ok: since we can assign a
						// Point3D to a Point
		p3da = pa;			// error: (cast needed) since a Point
						// can't be assigned to a Point3D
	}
<A name=190012></A>
}<P>
</P></PRE></BLOCKQUOTE><A name=190015></A>Assignment of a value of compile-time 
reference type <I>S</I> (source) to a variable of compile-time reference type 
<I>T</I> (target) is checked as follows:
<P>
<UL><A name=25632></A>
  <LI>If <I>S</I> is a class type: 
  <UL><A name=25636></A>
    <LI>If <I>T</I> is a class type, then <I>S</I> must either be the same class 
    as <I>T</I>, or <I>S</I> must be a subclass of <I>T</I>, or a compile-time 
    error occurs. <A name=25643></A>
    <LI>If <I>T</I> is an interface type, then <I>S</I> must implement interface 
    <I>T</I>, or a compile-time error occurs. <A name=25644></A>
    <LI>If <I>T</I> is an array type, then a compile-time error occurs. 
  </LI></UL><A name=176327></A>
  <LI>If <I>S</I> is an interface type: 
  <UL><A name=25655></A>
    <LI>If <I>T</I> is a class type, then <I>T</I> must be <CODE>Object</CODE>, 
    or a compile-time error occurs. <A name=25659></A>
    <LI>If <I>T</I> is an interface type, then <I>T</I> must be either the same 
    interface as <I>S</I> or a superinterface of <I>S</I>, or a compile-time 
    error occurs. <A name=25663></A>
    <LI>If <I>T</I> is an array type, then a compile-time error occurs. 
  </LI></UL><A name=25667></A>
  <LI>If <I>S</I> is an array type <I>SC</I><CODE>[]</CODE>, that is, an array 
  of components of type <I>SC</I>: 
  <UL><A name=25677></A>
    <LI>If <I>T</I> is a class type, then <I>T</I> must be <CODE>Object</CODE>, 
    or a compile-time error occurs. <A name=25678></A>
    <LI>If <I>T</I> is an interface type, then a compile-time error occurs 
    unless <I>T</I> is the type <CODE>java.io.Serializable</CODE> or the type 
    <CODE>Cloneable</CODE>, the only interfaces implemented by arrays. <A 
    name=25679></A>
    <LI>If <I>T</I> is an array type <I>TC</I><CODE>[]</CODE>, that is, an array 
    of components of type <I>TC</I>, then a compile-time error occurs unless one 
    of the following is true: 
    <UL><A name=25683></A>
      <LI><I>TC</I> and <I>SC</I> are the same primitive type. <A 
name=25684></A>
      <LI><I>TC</I> and <I>SC</I> are both reference types and type <I>SC</I> is 
      assignable to <I>TC</I>, as determined by a recursive application of these 
      compile-time rules for assignability. </LI></UL></LI></UL></LI></UL><A 
name=185485></A>See <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/classes.doc.html#3857">§8</A> 
for the specification of classes, <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/interfaces.doc.html#238678">§9</A> 
for interfaces, and <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/arrays.doc.html#27803">§10</A> 
for arrays.
<P><A name=56972></A>The following test program illustrates assignment 
conversions on reference values, but fails to compile because it violates the 
preceding rules, as described in its comments. This example should be compared 
to the preceding one. 
<BLOCKQUOTE><PRE>public class Point { int x, y; }
public interface Colorable { void setColor(int color); }
public class ColoredPoint extends Point implements Colorable 
{
	int color;
	public void setColor(int color) { this.color = color; }
}
class Test {
	public static void main(String[] args) {
		Point p = new Point();
		ColoredPoint cp = new ColoredPoint();
		// Okay because ColoredPoint is a subclass of Point:
		p = cp;
		// Okay because ColoredPoint implements Colorable:
		Colorable c = cp;
		// The following cause compile-time errors because
		// we cannot be sure they will succeed, depending on
		// the run-time type of p; a run-time check will be
		// necessary for the needed narrowing conversion and
		// must be indicated by including a cast:
		cp = p;				// p might be neither a ColoredPoint
						// nor a subclass of ColoredPoint
		c = p;				// p might not implement Colorable
	}
}
</PRE></BLOCKQUOTE><A name=29746></A>Here is another example involving 
assignment of array objects:
<P>
<BLOCKQUOTE><PRE>class Point { int x, y; }
class ColoredPoint extends Point { int color; }
class Test {
	public static void main(String[] args) {
		long[] veclong = new long[100];
		Object o = veclong;				// okay
		Long l = veclong;				// compile-time error
		short[] vecshort = veclong;			// compile-time error
		Point[] pvec = new Point[100];
		ColoredPoint[] cpvec = new ColoredPoint[100];
		pvec = cpvec;					// okay
		pvec[0] = new Point();				// okay at compile time,
								// but would throw an
								// exception at run time
		cpvec = pvec;					// compile-time error
	}
}
</PRE></BLOCKQUOTE><A name=29761></A>In this example:
<P>
<UL><A name=12615></A>
  <LI>The value of <CODE>veclong</CODE> cannot be assigned to a 
  <CODE>Long</CODE> variable, because <CODE>Long</CODE> is a class type other 
  than <CODE>Object</CODE>. An array can be assigned only to a variable of a 
  compatible array type, or to a variable of type <CODE>Object</CODE>. <A 
  name=12616></A>
  <LI>The value of <CODE>veclong</CODE> cannot be assigned to 
  <CODE>vecshort</CODE>, because they are arrays of primitive type, and 
  <CODE>short</CODE> and <CODE>long</CODE> are not the same primitive type. <A 
  name=12617></A>
  <LI>The value of <CODE>cpvec</CODE> can be assigned to 
  <CODE>pvec</CODE>,<CODE></CODE> because any reference that could be the value 
  of an expression of type <CODE>ColoredPoint</CODE> can be the value of a 
  variable of type <CODE>Point</CODE>. The subsequent assignment of the new 
  <CODE>Point</CODE> to a component of <CODE>pvec</CODE> then would throw an 
  <CODE>ArrayStoreException</CODE> (if the program were otherwise corrected so 
  that it could be compiled), because a <CODE>ColoredPoint</CODE> array can't 
  have an instance of <CODE>Point</CODE> as the value of a component. <A 
  name=29743></A>
  <LI>The value of <CODE>pvec</CODE> cannot be assigned to 
  <CODE>cpvec</CODE>,<CODE></CODE> because not every reference that could be the 
  value of an expression of type <CODE>ColoredPoint</CODE> can correctly be the 
  value of a variable of type <CODE>Point</CODE>. If the value of 
  <CODE>pvec</CODE> at run time were a reference to an instance of 
  <CODE>Point[]</CODE>, and the assignment to <CODE>cpvec</CODE> were allowed, a 
  simple reference to a component of <CODE>cpvec</CODE>, say, 
  <CODE>cpvec[0]</CODE>, could return a <CODE>Point</CODE>, and a 
  <CODE>Point</CODE> is not a <CODE>ColoredPoint</CODE>. Thus to allow such an 
  assignment would allow a violation of the type system. A cast may be used (<A 
  href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#20232">§5.5</A>, 
  <A 
  href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#238146">§15.16</A>) 
  to ensure that <CODE>pvec</CODE> references a <CODE>ColoredPoint[]</CODE>: 
  </LI></UL>
<BLOCKQUOTE><PRE>cpvec = (ColoredPoint[])pvec;		// okay, but may throw an
					// exception at run time
</PRE></BLOCKQUOTE><A name=12687></A>
<H2>5.3 Method Invocation Conversion</H2><A name=53171></A><EM>Method invocation 
conversion</EM> is applied to each argument value in a method or constructor 
invocation (<A 
href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#41147">§15.9</A>, 
<A 
href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#20448">§15.12</A>): 
the type of the argument expression must be converted to the type of the 
corresponding parameter. Method invocation contexts allow the use of an identity 
conversion <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#25209">(§5.1.1)</A>, 
a widening primitive conversion <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#25214">(§5.1.2)</A>, 
or a widening reference conversion <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#25215">(§5.1.4)</A>.
<P><A name=184237></A>If the type of an argument expression is either 
<CODE>float</CODE> or <CODE>double</CODE>, then value set conversion <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#184225">(§5.1.8)</A> 
is applied after the type conversion:
<P>
<UL><A name=184238></A>
  <LI>If an argument value of type <CODE>float</CODE> is an element of the 
  float-extended-exponent value set, then the implementation must map the value 
  to the nearest element of the float value set. This conversion may result in 
  overflow or underflow. <A name=184239></A>
  <LI>If an argument value of type <CODE>double</CODE> is an element of the 
  double-extended-exponent value set, then the implementation must map the value 
  to the nearest element of the double value set. This conversion may result in 
  overflow or underflow. <A name=185494></A></LI></UL>Method invocation 
conversions specifically do not include the implicit narrowing of integer 
constants which is part of assignment conversion <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#184206">(§5.2)</A>. 
The designers of the Java programming language felt that including these 
implicit narrowing conversions would add additional complexity to the overloaded 
method matching resolution process <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#289905">(§15.12.2)</A>. 
Thus, the example: 
<UL></UL>
<BLOCKQUOTE><PRE>class Test {
	static int m(byte a, int b) { return a+b; }
	static int m(short a, short b) { return a-b; }
	public static void main(String[] args) {
		System.out.println(m(12, 2));										// compile-time error
	}
}
</PRE></BLOCKQUOTE><A name=185593></A>causes a compile-time error because the 
integer literals <CODE>12</CODE> and <CODE>2</CODE> have type <CODE>int</CODE>, 
so neither method <CODE>m</CODE> matches under the rules of <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#289905">(§15.12.2)</A>. 
A language that included implicit narrowing of integer constants would need 
additional rules to resolve cases like this example.
<P><A name=186035></A>
<H2>5.4 String Conversion</H2><A name=176922></A>String conversion applies only 
to the operands of the binary <CODE>+</CODE> operator when one of the arguments 
is a <CODE>String</CODE>. In this single special case, the other argument to the 
<CODE>+</CODE> is converted to a <CODE>String</CODE>, and a new 
<CODE>String</CODE> which is the concatenation of the two strings is the result 
of the <CODE>+</CODE>. String conversion is specified in detail within the 
description of the string concatenation <CODE>+</CODE> operator <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#39990">(§15.18.1)</A>.
<P><A name=20232></A>
<H2>5.5 Casting Conversion</H2><A name=20233></A><EM>Casting conversion</EM> is 
applied to the operand of a cast operator <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#238146">(§15.16)</A>: 
the type of the operand expression must be converted to the type explicitly 
named by the cast operator. Casting contexts allow the use of an identity 
conversion <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#25209">(§5.1.1)</A>, 
a widening primitive conversion <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#25214">(§5.1.2)</A>, 
a narrowing primitive conversion <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#25363">(§5.1.3)</A>, 
a widening reference conversion <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#25215">(§5.1.4)</A>, 
or a narrowing reference conversion <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#25379">(§5.1.5)</A>. 
Thus casting conversions are more inclusive than assignment or method invocation 
conversions: a cast can do any permitted conversion other than a string 
conversion.
<P><A name=184265></A>Value set conversion <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#184225">(§5.1.8)</A> 
is applied after the type conversion.
<P><A name=183573></A>Some casts can be proven incorrect at compile time; such 
casts result in a compile-time error.
<P><A name=189992></A>A value of a primitive type can be cast to another 
primitive type by identity conversion, if the types are the same, or by a 
widening primitive conversion or a narrowing primitive conversion.
<P><A name=175724></A>A value of a primitive type cannot be cast to a reference 
type by casting conversion, nor can a value of a reference type be cast to a 
primitive type.
<P><A name=175725></A>The remaining cases involve conversion between reference 
types. The detailed rules for compile-time correctness checking of a casting 
conversion of a value of compile-time reference type <I>S</I> (source) to a 
compile-time reference type <I>T</I> (target) are as follows:
<P>
<UL><A name=27459></A>
  <LI>If <I>S</I> is a class type: 
  <UL><A name=27460></A>
    <LI>If <I>T</I> is a class type, then <I>S</I> and <I>T</I> must be related 
    classes-that is, <I>S</I> and <I>T</I> must be the same class, or <I>S</I> a 
    subclass of <I>T</I>, or <I>T</I> a subclass of <I>S</I>; otherwise a 
    compile-time error occurs. <A name=27461></A>
    <LI>If <I>T</I> is an interface type: 
    <UL><A name=26664></A>
      <LI>If <I>S</I> is not a <CODE>final</CODE> class <A 
      href="http://java.sun.com/docs/books/jls/second_edition/html/classes.doc.html#21613">(§8.1.1)</A>, 
      then the cast is always correct at compile time (because even if <I>S</I> 
      does not implement <I>T</I>, a subclass of <I>S</I> might). <A 
      name=26668></A>
      <LI>If <I>S</I> is a <CODE>final</CODE> class <A 
      href="http://java.sun.com/docs/books/jls/second_edition/html/classes.doc.html#21613">(§8.1.1)</A>, 
      then <I>S</I> must implement <I>T</I>, or a compile-time error occurs. 
      </LI></UL><A name=27505></A>
    <LI>If <I>T</I> is an array type, then <I>S</I> must be the class 
    <CODE>Object</CODE>, or a compile-time error occurs. </LI></UL><A 
  name=184308></A>
  <LI>If <I>S</I> is an interface type: 
  <UL><A name=184339></A>
    <LI>If <I>T</I> is an array type, then <I>T</I> must implement <I>S</I>, or 
    a compile-time error occurs. <A name=185598></A>
    <LI>If <I>T</I> is a class type that is not <CODE>final</CODE> <A 
    href="http://java.sun.com/docs/books/jls/second_edition/html/classes.doc.html#21613">(§8.1.1)</A>, 
    then the cast is always correct at compile time (because even if <I>T</I> 
    does not implement <I>S</I>, a subclass of <I>T</I> might). <A 
    name=45656></A>
    <LI>If <I>T</I> is an interface type and if <I>T</I> and <I>S</I> contain 
    methods with the same signature <A 
    href="http://java.sun.com/docs/books/jls/second_edition/html/classes.doc.html#38649">(§8.4.2)</A> 
    but different return types, then a compile-time error occurs. </LI></UL><A 
  name=53974></A>
  <LI>If <I>S</I> is an array type <I>SC</I><CODE>[]</CODE>, that is, an array 
  of components of type <I>SC</I>: 
  <UL><A name=53981></A>
    <LI>If <I>T</I> is a class type, then if <I>T</I> is not 
    <CODE>Object</CODE>, then a compile-time error occurs (because 
    <CODE>Object</CODE> is the only class type to which arrays can be assigned). 
    <A name=28948></A>
    <LI>If <I>T</I> is an interface type, then a compile-time error occurs 
    unless <I>T</I> is the type <CODE>java.io.Serializable</CODE> or the type 
    <CODE>Cloneable</CODE>, the only interfaces implemented by arrays. <A 
    name=28949></A>
    <LI>If <I>T</I> is an array type <I>TC</I><CODE>[]</CODE>, that is, an array 
    of components of type <I>TC</I>, then a compile-time error occurs unless one 
    of the following is true: 
    <UL><A name=176094></A>
      <LI><I>TC</I> and <I>SC</I> are the same primitive type. <A 
      name=176095></A>
      <LI><I>TC</I> and <I>SC</I> are reference types and type <I>SC</I> can be 
      cast to <I>TC</I> by a recursive application of these compile-time rules 
      for casting. </LI></UL></LI></UL></LI></UL><A name=184257></A>See <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/classes.doc.html#3857">§8</A> 
for the specification of classes, <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/interfaces.doc.html#238678">§9</A> 
for interfaces, and <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/arrays.doc.html#27803">§10</A> 
for arrays.
<P><A name=189942></A>If a cast to a reference type is not a compile-time error, 
there are two cases:
<P>
<UL><A name=26702></A>
  <LI>The cast can be determined to be correct at compile time. A cast from the 
  compile-time type <I>S</I> to compile-time type <I>T</I> is correct at compile 
  time if and only if <I>S</I> can be converted to <I>T</I> by assignment 
  conversion <A 
  href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#184206">(§5.2)</A>. 
  <A name=185505></A>
  <LI>The cast requires a run-time validity check. If the value at run time is 
  <CODE>null</CODE>, then the cast is allowed. Otherwise, let <I>R</I> be the 
  class of the object referred to by the run-time reference value, and let 
  <I>T</I> be the type named in the cast operator. A cast conversion must check, 
  at run time, that the class <I>R</I> is assignment compatible with the type 
  <I>T</I>, using the algorithm specified in <A 
  href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#184206">§5.2</A> 
  but using the class <I>R</I> instead of the compile-time type <I>S</I> as 
  specified there. (Note that <I>R</I> cannot be an interface when these rules 
  are first applied for any given cast, but <I>R</I> may be an interface if the 
  rules are applied recursively because the run-time reference value may refer 
  to an array whose element type is an interface type.) The modified algorithm 
  is shown here: 
  <UL><A name=29070></A>
    <LI>If <I>R</I> is an ordinary class (not an array class): 
    <UL><A name=29074></A>
      <LI>If <I>T</I> is a class type, then <I>R</I> must be either the same 
      class <A 
      href="http://java.sun.com/docs/books/jls/second_edition/html/typesValues.doc.html#97058">(§4.3.4)</A> 
      as <I>T</I> or a subclass of <I>T</I>, or a run-time exception is thrown. 
      <A name=29084></A>
      <LI>If <I>T</I> is an interface type, then <I>R</I> must implement <A 
      href="http://java.sun.com/docs/books/jls/second_edition/html/classes.doc.html#34031">(§8.1.4)</A> 
      interface <I>T</I>, or a run-time exception is thrown. <A name=29085></A>
      <LI>If <I>T</I> is an array type, then a run-time exception is thrown. 
      </LI></UL><A name=174679></A>
    <LI>If <I>R</I> is an interface: 
    <UL><A name=174686></A>
      <LI>If <I>T</I> is a class type, then <I>T</I> must be <CODE>Object</CODE> 
      (<A 
      href="http://java.sun.com/docs/books/jls/second_edition/html/typesValues.doc.html#11055">§4.3.2</A>), 
      or a run-time exception is thrown. <A name=174687></A>
      <LI>If <I>T</I> is an interface type, then <I>R</I> must be either the 
      same interface as <I>T</I> or a subinterface of <I>T</I>, or a run-time 
      exception is thrown. <A name=174682></A>
      <LI>If <I>T</I> is an array type, then a run-time exception is thrown. 
      </LI></UL><A name=29102></A>
    <LI>If <I>R</I> is a class representing an array type 
    <I>RC</I><CODE>[]</CODE>-that is, an array of components of type <I>RC</I>: 
    <UL><A name=29109></A>
      <LI>If <I>T</I> is a class type, then <I>T</I> must be <CODE>Object</CODE> 
      (<A 
      href="http://java.sun.com/docs/books/jls/second_edition/html/typesValues.doc.html#11055">§4.3.2</A>), 
      or a run-time exception is thrown. <A name=29110></A>
      <LI>If <I>T</I> is an interface type, then a run-time exception is thrown 
      unless <I>T</I> is the type <CODE>java.io.Serializable</CODE> or the type 
      <CODE>Cloneable</CODE>, the only interfaces implemented by arrays (this 
      case could slip past the compile-time checking if, for example, a 
      reference to an array were stored in a variable of type 
      <CODE>Object</CODE>). <A name=29114></A>
      <LI>If <I>T</I> is an array type <I>TC</I><CODE>[]</CODE>, that is, an 
      array of components of type <I>TC</I>, then a run-time exception is thrown 
      unless one of the following is true: 
      <UL><A name=29118></A>
        <LI><I>TC</I> and <I>RC</I> are the same primitive type. <A 
        name=184534></A>
        <LI><I>TC</I> and <I>RC</I> are reference types and type <I>RC</I> can 
        be cast to <I>TC</I> by a recursive application of these run-time rules 
        for casting. </LI></UL></LI></UL></LI></UL></LI></UL><A name=185512></A>If a 
run-time exception is thrown, it is a <CODE>ClassCastException</CODE>.
<P><A name=189995></A>Here are some examples of casting conversions of reference 
types, similar to the example in <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#184206">§5.2</A>:
<P>
<BLOCKQUOTE><PRE>public class Point { int x, y; }
public interface Colorable { void setColor(int color); }
public class ColoredPoint extends Point implements Colorable 
{
	int color;
	public void setColor(int color) { this.color = color; }
}
final class EndPoint extends Point { }
class Test {
	public static void main(String[] args) {
		Point p = new Point();
		ColoredPoint cp = new ColoredPoint();
		Colorable c;

		// The following may cause errors at run time because
		// we cannot be sure they will succeed; this possibility
		// is suggested by the casts:
		cp = (ColoredPoint)p;		// p might not reference an
						// object which is a ColoredPoint
						// or a subclass of ColoredPoint
		c = (Colorable)p;		// p might not be Colorable

		// The following are incorrect at compile time because
		// they can never succeed as explained in the text:
		Long l = (Long)p;		// compile-time error #1
		EndPoint e = new EndPoint();
		c = (Colorable)e;		// compile-time error #2
	}
}
</PRE></BLOCKQUOTE><A name=29315></A>Here the first compile-time error occurs 
because the class types <CODE>Long</CODE> and <CODE>Point</CODE> are unrelated 
(that is, they are not the same, and neither is a subclass of the other), so a 
cast between them will always fail.
<P><A name=176389></A>The second compile-time error occurs because a variable of 
type <CODE>EndPoint</CODE> can never reference a value that implements the 
interface <CODE>Colorable</CODE>. This is because <CODE>EndPoint</CODE> is a 
<CODE>final</CODE> type, and a variable of a <CODE>final</CODE> type always 
holds a value of the same run-time type as its compile-time type. Therefore, the 
run-time type of variable <CODE>e</CODE> must be exactly the type 
<CODE>EndPoint</CODE>, and type <CODE>EndPoint</CODE> does not implement 
<CODE>Colorable</CODE>. <A name=189949></A>
<P>Here is an example involving arrays <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/arrays.doc.html#27803">(§10)</A>: 

<BLOCKQUOTE><PRE>class Point {
	int x, y;
	Point(int x, int y) { this.x = x; this.y = y; }
	public String toString() { return "("+x+","+y+")"; }
}
public interface Colorable { void setColor(int color); }
public class ColoredPoint extends Point implements Colorable 
{
	int color;
	ColoredPoint(int x, int y, int color) {
		super(x, y); setColor(color);
	}
	public void setColor(int color) { this.color = color; }
	public String toString() {
		return super.toString() + "@" + color;
	}
}
class Test {
	public static void main(String[] args) {
		Point[] pa = new ColoredPoint[4];
		pa[0] = new ColoredPoint(2, 2, 12);
		pa[1] = new ColoredPoint(4, 5, 24);
		ColoredPoint[] cpa = (ColoredPoint[])pa;
		System.out.print("cpa: {");
		for (int i = 0; i &lt; cpa.length; i++)
			System.out.print((i == 0 ? " " : ", ") + cpa[i]);
		System.out.println(" }");
	}
}
</PRE></BLOCKQUOTE><A name=53223></A>This example compiles without errors and 
produces the output:
<P>
<BLOCKQUOTE><PRE>cpa: { (2,2)@12, (4,5)@24, null, null }
<A name=176370></A>
</PRE></BLOCKQUOTE>The following example uses casts to compile, but it throws 
exceptions at run time, because the types are incompatible: 
<BLOCKQUOTE><PRE>public class Point { int x, y; }
public interface Colorable { void setColor(int color); }
public class ColoredPoint extends Point implements Colorable 
{
	int color;
	public void setColor(int color) { this.color = color; }
}
class Test {
	public static void main(String[] args) {
		Point[] pa = new Point[100];
		// The following line will throw a ClassCastException:
		ColoredPoint[] cpa = (ColoredPoint[])pa;
		System.out.println(cpa[0]);
		int[] shortvec = new int[2];
		Object o = shortvec;
		// The following line will throw a ClassCastException:
		Colorable c = (Colorable)o;
		c.setColor(0);
	}
<A name=185611></A>
}<P>
</P></PRE></BLOCKQUOTE><A name=26917></A>
<H2>5.6 Numeric Promotions</H2><A name=26918></A><EM>Numeric promotion</EM> is 
applied to the operands of an arithmetic operator. Numeric promotion contexts 
allow the use of an identity conversion <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#25209">(§5.1.1)</A> 
or a widening primitive conversion <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#25214">(§5.1.2)</A>.
<P><A name=53304></A>Numeric promotions are used to convert the operands of a 
numeric operator to a common type so that an operation can be performed. The two 
kinds of numeric promotion are unary numeric promotion <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#170952">(§5.6.1)</A> 
and binary numeric promotion<EM> </EM><A 
href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#170983">(§5.6.2)</A>. 
The analogous conversions in C are called "the usual unary conversions" and "the 
usual binary conversions."
<P><A name=170949></A>Numeric promotion is not a general feature of the Java 
programming language, but rather a property of the specific definitions of the 
built-in operations.
<P><A name=170952></A>
<H3>5.6.1 Unary Numeric Promotion</H3><A name=170954></A>Some operators apply 
<EM>unary numeric promotion</EM> to a single operand, which must produce a value 
of a numeric type:
<P>
<UL><A name=20278></A>
  <LI>If the operand is of compile-time type <CODE>byte</CODE>, 
  <CODE>short</CODE>, or <CODE>char</CODE>, unary numeric promotion promotes it 
  to a value of type <CODE>int</CODE> by a widening conversion <A 
  href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#25214">(§5.1.2)</A>. 
  <A name=20279></A>
  <LI>Otherwise, a unary numeric operand remains as is and is not converted. 
  </LI></UL><A name=183582></A>In either case, value set conversion <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#184225">(§5.1.8)</A> 
is then applied.
<P><A name=23183></A>Unary numeric promotion is performed on expressions in the 
following situations:
<P>
<UL><A name=175745></A>
  <LI>Each dimension expression in an array creation expression <A 
  href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#46168">(§15.10)</A> 
  <A name=23187></A>
  <LI>The index expression in an array access expression <A 
  href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#239587">(§15.13)</A> 
  <A name=170969></A>
  <LI>The operand of a unary plus operator <CODE>+</CODE> <A 
  href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#24924">(§15.15.3)</A> 
  <A name=183601></A>
  <LI>The operand of a unary minus operator <CODE>-</CODE> <A 
  href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#236345">(§15.15.4)</A> 
  <A name=170977></A>
  <LI>The operand of a bitwise complement operator <CODE>~</CODE> <A 
  href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#5017">(§15.15.5)</A> 
  <A name=170981></A>
  <LI>Each operand, separately, of a shift operator <CODE>&gt;&gt;</CODE>, 
  <CODE>&gt;&gt;&gt;</CODE>, or <CODE>&lt;&lt;</CODE> <A 
  href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#5121">(§15.19)</A>; 
  therefore a <CODE>long</CODE> shift distance (right operand) does not promote 
  the value being shifted (left operand) to <CODE>long</CODE> <A 
name=185521></A>
  <P>Here is a test program that includes examples of unary numeric promotion: 
  </P></LI></UL>
<BLOCKQUOTE><PRE>class Test {
	public static void main(String[] args) {
		byte b = 2;
		int a[] = new int[b];	// dimension expression promotion
		char c = '\u0001';
		a[c] = 1;			// index expression promotion
		a[0] = -c;			// unary - promotion
		System.out.println("a: " + a[0] + "," + a[1]);
		b = -1;
		int i = ~b;			// bitwise complement promotion
		System.out.println("~0x" + Integer.toHexString(b)
							+ "==0x" + Integer.toHexString(i));
		i = b &lt;&lt; 4L;		// shift promotion (left operand)
		System.out.println("0x" + Integer.toHexString(b)
					 + "&lt;&lt;4L==0x" + Integer.toHexString(i));
	}
}
</PRE></BLOCKQUOTE><A name=30172></A>This test program produces the output:
<P>
<BLOCKQUOTE><PRE>a: -1,1
~0xffffffff==0x0
0xffffffff&lt;&lt;4L==0xfffffff0
</PRE></BLOCKQUOTE><A name=170983></A>
<H3>5.6.2 Binary Numeric Promotion</H3><A name=183615></A>When an operator 
applies <EM>binary numeric promotion</EM> to a pair of operands, each of which 
must denote a value of a numeric type, the following rules apply, in order, 
using widening conversion <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#25214">(§5.1.2)</A> 
to convert operands as necessary:
<P>
<UL><A name=183619></A>
  <LI>If either operand is of type <CODE>double</CODE>, the other is converted 
  to <CODE>double</CODE>. <A name=183620></A>
  <LI>Otherwise, if either operand is of type <CODE>float</CODE>, the other is 
  converted to <CODE>float</CODE>. <A name=170988></A>
  <LI>Otherwise, if either operand is of type <CODE>long</CODE>, the other is 
  converted to <CODE>long</CODE>. <A name=170989></A>
  <LI>Otherwise, both operands are converted to type <CODE>int</CODE>. 
</LI></UL><A name=183628></A>After the type conversion, if any, value set 
conversion <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#184225">(§5.1.8)</A> 
is applied to each operand.
<P><A name=183623></A>Binary numeric promotion is performed on the operands of 
certain operators:
<P>
<UL><A name=170994></A>
  <LI>The multiplicative operators <CODE>*</CODE>, <CODE>/</CODE> and 
  <CODE>%</CODE> <A 
  href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#239829">(§15.17)</A> 
  <A name=170998></A>
  <LI>The addition and subtraction operators for numeric types <CODE>+</CODE> 
  and <CODE>- </CODE><A 
  href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#13510">(§15.18.2)</A> 
  <A name=171002></A>
  <LI>The numerical comparison operators <CODE>&lt;</CODE>, <CODE>&lt;=</CODE>, 
  <CODE>&gt;</CODE>, and <CODE>&gt;=</CODE> <A 
  href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#153654">(§15.20.1)</A> 
  <A name=171006></A>
  <LI>The numerical equality operators <CODE>==</CODE> and <CODE>!=</CODE> <A 
  href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#5198">(§15.21.1)</A> 
  <A name=171010></A>
  <LI>The integer bitwise operators <CODE>&amp;</CODE>, <CODE>^</CODE>, and 
  <CODE>|</CODE> <A 
  href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#5233">(§15.22.1)</A> 
  <A name=171014></A>
  <LI>In certain cases, the conditional operator <CODE>? :</CODE> <A 
  href="http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html#290293">(§15.25)</A> 
  </LI></UL><A name=7306></A>
<P><A name=185529></A>An example of binary numeric promotion appears above in <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html#189955">§5.1</A>. 
Here is another: 
<BLOCKQUOTE><PRE>class Test {
	public static void main(String[] args) {
		int i = 0;
		float f = 1.0f;
		double d = 2.0;
		// First int*float is promoted to float*float, then
		// float==double is promoted to double==double:
		if (i * f == d)
			System.out.println("oops");
		// A char&amp;byte is promoted to int&amp;int:
		byte b = 0x1f;
		char c = 'G';
		int control = c &amp; b;
		System.out.println(Integer.toHexString(control));
		// Here int:float is promoted to float:float:
		f = (b==0) ? i : 4.0f;
		System.out.println(1.0/f);
	}
}
</PRE></BLOCKQUOTE><A name=17465></A>which produces the output:
<P>
<BLOCKQUOTE><PRE>7
0.25
</PRE></BLOCKQUOTE><A name=185621></A>The example converts the ASCII character 
<CODE>G</CODE> to the ASCII control-G (BEL), by masking off all but the low 5 
bits of the character. The <CODE>7</CODE> is the numeric value of this control 
character. 
<P>
<HR>

<TABLE width="100%" border=0>
  <TBODY>
  <TR>
    <TD><A 
      href="http://java.sun.com/docs/books/jls/second_edition/html/jTOC.doc.html">Contents</A> 
      | <A 
      href="http://java.sun.com/docs/books/jls/second_edition/html/typesValues.doc.html">Prev</A> 
      | <A 
      href="http://java.sun.com/docs/books/jls/second_edition/html/names.doc.html">Next</A> 
      | <A 
      href="http://java.sun.com/docs/books/jls/second_edition/html/jIX.fm.html">Index</A></TD>
    <TD align=right><I>Java Language Specification</I><BR><FONT size=-1>Second 
      Edition</FONT></TD></TR></TBODY></TABLE><I><A 
href="http://java.sun.com/docs/books/jls/second_edition/html/jcopyright.doc.html">Copyright</A> 
© 2000 Sun Microsystems, Inc. All rights reserved</I> <BR>Please send any 
comments or corrections via our <A 
href="http://developers.sun.com/contact/feedback.jsp?&amp;category=doc&amp;mailsubject=Java%20Language%20Specification%20Feedback">feedback 
form</A> </FONT>
<SCRIPT language=JavaScript 
src="Conversions and Promotions_files/s_code_remote.js"></SCRIPT>
</BODY></HTML>
